'''
This is the first script to run 

Scan all asm files in the directory and return the following information
1)1-gram opcodes in original sequence
2)Ranges of all loops
3)Memory allocation:
    DB	Define Byte	allocates 1 byte
    DW	Define Word	allocates 2 bytes
    DD	Define Doubleword	allocates 4 bytes
    DQ	Define Quadword	allocates 8 bytes
    DT	Define Ten Bytes	allocates 10 bytes
    RESB	Reserve a Byte
    RESW	Reserve a Word
    RESD	Reserve a Doubleword
    RESQ	Reserve a Quadword
    REST	Reserve a Ten Bytes
Output file
1) csv file: [filename,1-gram raw opcode]
2) csv file: [filename, loop ranges]
3) csv file: [filename,all memory allocation keyword]
4) csv file: [filename, 1-gram raw opcode in loop or not]
'''

import collections
import ConfigParser
import csv
import datetime
import os
import re
import string
import sys


Config = ConfigParser.ConfigParser()
Config.read("/home/amber/Malware/config")
path = Config.get("Train","asm") #Path to the assembly source code data
path = Config.get("Train","feature_save") #Path for saving extracted asm image feature


#Helper Function: load all .asm files in the directory
def load(filepath):
    
    asm = []
    for item in os.listdir(filepath):
        if item.endswith(".asm"):
            asm.append(item)
    return asm

#Helper Function: check if a string represents a hex
def ishex(string):
    exeption = ["add","dec","db","dd"]
    if(string in exeption):
        return False
    else:
        try:
            int(string,16)
        except:
            return False
        return True


#Saving the scanning orders
#All features will be extracted using this ordering of the file later on
filedone = []
try:
    with open(os.path.join(path_out,"filedone_scan.csv")) as f:
    	for line in f:
            filedone.append(line.strip())
except:
    pass


time = datetime.datetime.now()
print("Scanning asm file")
print(time)
with open(os.path.join(path_out,"log.csv"), "ab") as fp:
    wr = csv.writer(fp)
    wr.writerow([(str(time))])
    wr.writerow(["------------------Scanning asm file for 1st round--------------------"])

files = load(path)
os.chdir(path)


filecount = 0
for filename in files:
    if(filename in filedone):
        print("Done scanning asm file: "+str(filecount)+" "+filename)
    else:
        filecount += 1
        print("Scanning asm file: "+str(filecount)+" "+filename)
        with open(os.path.join(path_out,"log.csv"), "ab") as fp:
            wr = csv.writer(fp)
            row = [("Scanning asm file: "+str(filecount)+" "+filename)]
            wr.writerow(row)

        memory_keyword = ["db","dw","dd","dq","dt","resb","resw","resd","resq","rest"]
        exeption = set(string.punctuation)-set(".")
        one_gram = []
        memory_allocation = []
        one_gram_line = []
        line_num = 0
        loop_range = []
        loop_boolean = []
        THRESHOLD = 100
        FORMAT = ""
        Format_found = False  
        memory_buffer = collections.deque([],maxlen=THRESHOLD)

        with(open(filename)) as f:
            for line in f:

                line_num += 1   
                opcode = ""
                memWord = ""
                tokenized  = re.split(" |\t|''|:",line)
                tokenized = [x for x in tokenized if x]

                #Determine the format of the file
                try:
                    if(Format_found == False):
                        if(line.startswith("; Format") or line.startswith("// Format") ): 
                            idx = tokenized.index("Format")
                            file_format = tokenized[idx+1]
                            FORMAT = file_format
                            Format_found ==True
                except:
                     with open(os.path.join(path_out,"log.csv"), "ab") as fp:
                            wr = csv.writer(fp)
                            wr.writerow(["Error processing file format: "+filename])


                #Process first token  
                first_token = ""
                if(tokenized[0]==";" or tokenized[0] =="//"): #Ignore comments line
                    pass
                else:
                    first_token = tokenized[0].strip()
                    if(FORMAT=="Portable"): #Process PE format file
                        if(not any(char in string.punctuation for char in first_token)): #Ignore memory locations
                            if(first_token in memory_keyword): #Add memory allocation code
                                memWord = first_token
                                memory_allocation.append(memWord)
                            else:
                                opcode = first_token  
                    else: #Process Microsoft .net file and others
                        if(first_token.startswith(".")):
                            memWord = first_token
                            memory_allocation.append(memWord)

                        elif(not any(char in exeption for char in first_token) and not ishex(first_token)):
                            opcode = first_token


                #Check loop
                if opcode != "" and opcode != None:# Found one opcode
                    one_gram.append(opcode)
                    one_gram_line.append(line_num)

                    if((opcode.startswith("j") or opcode.startswith("b")) and opcode != "break" and opcode !="bool"
                      and opcode !="box"): #Found a potential loop
                            loop_end = line_num
                            loop_start = -1

                            des_idx = tokenized.index(opcode)+1
                            des = ""
                            if (tokenized[des_idx] == "far" or tokenized[des_idx] == "short"):
                                des = tokenized[des_idx+1].strip()
                            else:
                                des = tokenized[des_idx].strip()
                            #Search backwards to see if there is a starting point of the loop
                            Found_loop = False
                            idx= 1
                            opcode_in_between = []
                            for item in memory_buffer:
                                opcode_in_between.append(item)
                                if(item == des and "call" not in opcode_in_between):    
                                    Found_loop = True
                                    loop_start = line_num-idx
                                    break
                                idx += 1

                            if(Found_loop):
                                pair = [loop_start,loop_end]
                                loop_range.append(pair)

                memory_buffer.extendleft([first_token])

            #Write to csv file
            to_write_opcode = []
            to_write_opcode.append(filename)
            to_write_opcode.append(FORMAT)
            to_write_opcode.extend(one_gram)

            to_write_line = []
            to_write_line.append(filename)
            to_write_line.append(FORMAT)
            to_write_line.extend(loop_range)

            to_write_memoryCode =[]
            to_write_memoryCode.append(filename)
            to_write_memoryCode.append(FORMAT)
            to_write_memoryCode.extend(memory_allocation)

            to_write_opcodeline = []
            to_write_opcodeline.append(filename)
            to_write_opcodeline.append(FORMAT)
            to_write_opcodeline.extend(one_gram_line)

            with open(os.path.join(path_out,"one_gram_raw.csv"), "ab") as fp:
                wr = csv.writer(fp)
                wr.writerow(to_write_opcode)

            with open(os.path.join(path_out,"loop_range.csv"), "ab") as fp:
                wr = csv.writer(fp)
                wr.writerow(to_write_line)

            with open(os.path.join(path_out,"one_gram_line.csv"), "ab") as fp:
                wr = csv.writer(fp)
                wr.writerow(to_write_opcodeline)

            with open(os.path.join(path_out,"memory_allocation_word.csv"), "ab") as fp:
                wr = csv.writer(fp)
                wr.writerow(to_write_memoryCode)


            with open(os.path.join(path_out,"filedone_scan.csv"),"ab") as fp:
                wr = csv.writer(fp)
                wr.writerow([filename])


